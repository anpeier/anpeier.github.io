{"meta":{"title":"随遇而安","subtitle":"随遇而安","description":"一个有梦想的程序员","author":"随遇而安","url":"http://anpeier.github.io"},"pages":[{"title":"about","date":"2019-11-20T09:25:30.000Z","updated":"2019-12-09T14:21:49.359Z","comments":true,"path":"about/index.html","permalink":"http://anpeier.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2019-11-20T09:25:30.000Z","updated":"2019-12-09T14:22:18.639Z","comments":true,"path":"contact/index.html","permalink":"http://anpeier.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2019-11-20T13:25:30.000Z","updated":"2019-12-09T14:22:34.006Z","comments":true,"path":"friends/index.html","permalink":"http://anpeier.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-11-20T10:23:38.000Z","updated":"2019-12-09T14:23:49.110Z","comments":true,"path":"tags/index.html","permalink":"http://anpeier.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-11-20T09:25:30.000Z","updated":"2019-12-09T14:21:22.936Z","comments":true,"path":"categories/index.html","permalink":"http://anpeier.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Vue组件化开发之通用型弹出框","slug":"Modal","date":"2020-03-15T01:42:41.236Z","updated":"2020-03-15T01:53:06.063Z","comments":true,"path":"2020/03/15/modal/","link":"","permalink":"http://anpeier.github.io/2020/03/15/modal/","excerpt":"","text":"本文主要分享关于组件化开发的理解，让刚入门的小伙伴少走一些弯路，提高开发效率，作者本人也是新手，如有不当之处，请大佬指出，感谢。 ​ 相信很多刚入门的小伙伴，经常会写很多重复的代码，而这些代码一般情况下也都是大同小异，在这种情况下，如何让开发和学习变得更加高效，组件化的思想就显得尤为重要。这里通过设计一个简单的弹出框，给小伙伴们分享组件化的应用。 组件&amp;组件化 组件化是对某些可以进行复用的功能进行封装的标准化工作。组件一般会内含自身的内部UI元素、样式和JS逻辑代码，它可以很方便的在应用的任何地方进行快速的嵌入。组件内部可以使用其他组件来构成更复杂的组件。 在实际的开发中，我们应该避免去编写重复的代码，将精力放在更加核心的部分，因此就需要将这些重复的代码抽取出来，封装成公共的组件，提高开发效率，但同时也要注意组件的健壮性和可复用性，让它能够尽可能适应更多的场景。 基本结构首先是弹出框的基本结构 &lt;div class=\"modal\"> &lt;div class=\"mask\">&lt;/div> &lt;div class=\"modal-dialog\"> &lt;div class=\"modal-header\"> &lt;span>标题&lt;/span> &lt;a href=\"javascript:;\" class=\"icon-close\">&lt;/a> &lt;/div> &lt;div class=\"modal-body\"> &lt;slot name=\"body\">&lt;/slot> &lt;/div> &lt;div class=\"modal-footer\"> &lt;a href=\"javascript:;\" class=\"btn\">确定&lt;/a> &lt;a href=\"javascript:;\" class=\"btn btn-default\">取消&lt;/a> &lt;/div> &lt;/div> &lt;/div> &lt;/div> ​ 基本结构很简单，稍微注意一点的就是slot插槽，如果没有提供name属性，它将有一个隐含的名字default，并且在父组件如果没有指定slot的v-slot属性的话，内容会传给default插槽。 ​ 在这里定义了slot的name属性body，这种的叫做具名插槽，会匹配v-slot:body的内容。 注意，在父组件中调用需要用&lt;template&gt;包裹，并且&lt;template&gt; 元素中的所有内容都将被传入相应的插槽。 给弹出框加点样式 .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; .mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000000; opacity: 0.5; } .modal-dialog { position: absolute; top: 40%; left: 50%; width: 560px; height: auto; background-color: #ffffff; transform: translate(-50%, -50%); .modal-header { height: 60px; background-color: #F5F5F5; padding: 0 25px; line-height: 60px; font-size: 16px; .icon-close { position: absolute; top: 23px; right: 25px; width: 14px; height: 14px; background: url(\"/static/img/icon-close.png\") no-repeat center; background-size: contain; } } .modal-body { padding: 42px 40px 54px; font-size: 14px; } .modal-footer { height: 82px; line-height: 82px; text-align: center; background-color: #F5F5F5; } } } 我这里使用的是scss，使用的时候别忘了安装node-sass和sass-loader，现在我们的页面是这个样子了 虽然还是不太美观，但是已经基本上是一个弹出框的雏形了，并且我没有给a标记样式，原因在后面。 SCSS函数回过头再看看上面的css代码，这里重复写了4次固定定位的代码，而且随着项目的推进，肯定还有更多类似的代码，何不将这些部分抽取出来，进行封装呢？scss提供了这个功能，将css封装成函数，这里的函数直接会返回函数体。我们在遇到类似的情况时，就能够直接复用。 在assets目录下新建scss文件夹并在里面新建mixin.scss，在里面新建position函数,代码如下： @mixin position($pos: absolute, $top: 0, $left: 0, $w: 100%, $h: 100%) { position: $pos; top: $top; left: $left; width: $w; height: $h; } 接着我们引入mixin.scss，用position函数替换我们原先的代码 通过@include方式使用scss函数：@include position(fixed);括号里面的是参数。 关于按钮每一个网站都有很多按钮，不过，同一个网站的按钮风格大多都是一样，无非是大小不一。因此可以单独在scss文件下新建button.scss然后在App.vue里面引入这个文件，在后面除了一些特别的样式，其它就不需要给按钮定义样式了，这样也便于维护。这里给出我的button文件，可以参考一下。 .btn { display: inline-block; width: 110px; line-height: 30px; text-align: center; background-color: #FF6600; color: #ffffff; border: none; cursor: pointer; } .btn-default { background-color: #b0b0b0; color: #d7d7d7; } .btn-large { width: 202px; height: 50px; line-height: 50px; font-size: 18px; } .btn-huge { width: 300px; height: 54px; line-height: 54px; font-size: 16px; } .btn-group { .btn { margin-right: 20px; &amp;:last-child { margin-right: 0; } } } 为了复用当前这个弹出框还只是一个固定的结构，它并不能在其他地方复用，需要进行一些处理，将所有可变部分抽取出来，例如标题，按钮，内容。因为有插槽，所以内容就不用考虑，需要关注的是标题和按钮，因为标题有可能是提示，警告等等，按钮也有可能是确定、取消的一个或两个都有。而这些信息都是从父组件传递过来，需要用props接收。 在props里面添加如下代码，并给某些属性指定默认值： props: { // 弹框标题 title: String, // 按钮类型： 1：确定按钮 2：取消按钮 3：确定取消 btnType: String, // 按钮文本 sureText: { type: String, default: \"确定\" }, cancleText: { type: String, default: \"取消\" }, showModal: Boolean } 添加完之后，还需重新改写代码 &lt;div class=\"modal\" v-show=\"showModal\"> &lt;div class=\"mask\">&lt;/div> &lt;div class=\"modal-dialog\"> &lt;div class=\"modal-header\"> &lt;span>{{title}}&lt;/span> &lt;a href=\"javascript:;\" class=\"icon-close\" @click=\"$emit('cancle')\">&lt;/a> &lt;/div> &lt;div class=\"modal-body\"> &lt;slot name=\"body\">&lt;/slot> &lt;/div> &lt;div class=\"modal-footer\"> &lt;a href=\"javascript:;\" class=\"btn\" v-if=\"btnType==1\"@click=\"$emit('submit')\"{{sureText}}&lt;/a> &lt;a href=\"javascript:;\" class=\"btn\" v-if=\"btnType==2\"@click=\"$emit('cancle')\">{{cancleText}}&lt;/a> &lt;div class=\"btn-group\" v-if=\"btnType==3\"> &lt;a href=\"javascript:;\" class=\"btn\" @click=\"$emit('submit')\">{{sureText}}&lt;/a> &lt;a href=\"javascript:;\" class=\"btn btn-default\" @click=\"$emit('submit')\">{{cancleText}}&lt;/a> &lt;/div> &lt;/div> &lt;/div> &lt;/div> 通过父组件传递的参数，来实现代码的重用，并且使用$emit来向外抛出自定义事件，然后在父组件实现自己的业务逻辑。 在Home.vue里面引入这个组件并调用 给个小星星吧 这里的@submit和@cancle就是我们在组件里面自定义的事件 最终效果如下 实现完之后，感觉有点弹出时生硬，没关系，我们给它加点动画，在css3中有transform和transition可以实现动画效果，但是我们这里使用vue内置组件&lt;transition&gt;，让弹出框有一个从上面弹出的效果。 transition组件transition组件可以为元素或组件添加过渡效果，只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。它可以通过多种方式进行过渡，在这里应用 class的方式过渡。 这幅图是Vue官方给出的图，简单来说，v-enter是动画开始的状态，v-enter-active进入过渡生效时的状态,v-enter-to是过渡的结束状态，leave同理，具体细节大家可以去https://cn.vuejs.org/v2/guide/transitions.html#%E6%A6%82%E8%BF%B0查看。 当没有指定的name属性时，过渡的类名会默认以v作为前缀，这里给transition指定name为 slide并用它包裹modal组件 &lt;transition name=\"slide\"> &lt;div class=\"modal\" v-show=\"showModal\"> ... ... &lt;/div> &lt;/transition> 在style代码里面modal后面加上 &amp;.slide-enter-active { top: 0; } &amp;.slide-leave-active { top: -100%; } &amp;.slide-enter { top: -100%; } 并且给modal指定需要过渡的属性 transition: top 0.5s; 加完这个之后，弹出框就会有一个滑上滑下的动画啦。 到此，我们的弹出框就完成啦。 你也可以根据自己的需求去做适当的调整，开发出适合自己项目的弹出框。 做成插件每次在用这个弹出框的时候，还需要引入组件，也显得有点麻烦，因此，可以将其做成插件，能够全局调用，而不需要去引入。 在当前目录下新建index.js，通过使用install方法将其全局注册 import Modal from './Modal.vue' const component = { install: function (Vue) { Vue.component('Modal', Modal) } } export default component 在main.js引入，并通过Vue.use()来全局使用，这样就能像其他ui库一样去使用它而不需要每次引入。 最后在实际开发中，组件化是尤为重要的，它能够帮助我们写出更高质量的代码，也能够让我们的代码更易于维护，尽早的树立组件化的思想，对写代码也是非常有帮助的。 本文只是对组件化的简单理解，有不对的地方，欢迎大佬指出。 感谢评论区大佬的点拨。 希望看完的朋友可以给个赞，鼓励一下附上https://github.com/anpeier/shop-online/blob/master/src/components/Modal.vue document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://anpeier.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://anpeier.github.io/tags/Vue/"},{"name":"组件化思维","slug":"组件化思维","permalink":"http://anpeier.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%9D%E7%BB%B4/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://anpeier.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"快速上手网易云音乐可视化","slug":"visualize","date":"2019-11-23T04:53:55.822Z","updated":"2019-12-09T14:33:14.396Z","comments":true,"path":"2019/11/23/visualize/","link":"","permalink":"http://anpeier.github.io/2019/11/23/visualize/","excerpt":"","text":"什么是音频可视化 音频可视化，顾名思义，就是通过获取音频的波形、频率和其他来自音频的数据转换成图像，再到屏幕上显示出来。通过它，我们能够制作一些炫酷的前端音乐界面。 下面，我将分析一个来自云音乐技术团队的音频可视化开发案例，快速帮助小白，制作自己喜欢的炫酷的音频可视化界面。 先上图 想开发这么一个炫酷的音频界面，我们可以先来聊聊 canvas canvas是什么canvas是HTML5中用于图形绘制的容器元素，它通常通过JavaScript脚本来完成图形绘制。要完成我们下面的音频可视化开发，我们可以借组结构canvas的几个方法，下面将通过开发一个页面倒计时的小案例来帮助初学者了解canvas的一些属性和方法。 先上代码 &lt;canvas id=\"myCanvas\"> &lt;/canvas> &lt;script> const canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); ctx.fillStyle = 'red'; ctx.font = \"50px Verdana\"; let dis = 550; let i = 10; function animation(){ requestAnimationFrame(function(){ if(dis >= 0){ --dis; if(dis%50 == 0 ){ ctx.clearRect(0,0,300,150); ctx.fillText(i--,100,100); } animation(); } }); } animation(); &lt;/script> 我们在html页面创建一个canvas画布元素并设置id为myCanvas，它的默认大小是300*150，创建好了这块画布，接下来我们就能在JavaScript脚本中绘制图形了。 先通过getElementById()找到这个元素，然后创建canvas对象ctx并设置填充色为红色，字体为Verdana，大小为50px，设置dis变量用于条件控制，再定义一个i变量用于显示倒计时数字，然后我们就可以开始在我们的画布里绘制倒计时数字了。 创建一个animation函数，在这个函数里面，我们使用了一个html5专门用于请求动画的APIrequestAnimationFrame请求动画帧，相比于定时器setTimeout，它不会引起丢帧、丢帧，看起来更加流畅。 在requestAnimationFrame里面，先设置刷帧条件dis&gt;=0，dis每次减一，总共550次，再设置条件为每50次执行一次绘制操作，在每次绘制之前，通过clearRect(x,y,width,height)方法将画布上给定矩形清空，它的4个参数分别表示要清除的矩形左上角的x，y坐标，以及要清空矩形的宽度和高度，单位以像素计算。然后再通过fillText()画布指定位置绘制倒计时数字,该方法接收四个参数：text输出的文本，x绘制文本的x坐标，y绘制文本的y坐标，注意：这两个值都是相对于画布，最后一个参数maxWidth表示允许文本的最大宽度，它是一个可选参数。 接着我们通过递归的方式调用animation()函数直到倒计时结束，最后在外部调用一下animation()函数，至此，一个简单的倒计时界面完成。我们还可以给canvas通过innerWidth和innerHeight设置 画布大小。 canvas可以绘制各种图形，更多内容请自行参看canvas内容 聊完了canvas，接下来就是我们的正题了。 Web Audio在开始之前，我们还需要了解什么是Web Audio。 Web Audio 是 Web 端处理和分析音频的一套 API 。它可以使用户在音频上下文中进行音频操作，具有模块化路由的特点，它也使我们能够控制音频的空间化。 通过Web Audio，我们能够实现取数据和映射数据两个过程，下面我们将实现这两个过程。 项目实现我们先在页面创建一个canvas元素和一个audio标签以及一个用于作播放按钮的a标签。 然后在JavaScript里面获取audio和a这两个元素，并给a标签设置单击事件。 var btn = document.getElementById('play-btn'); var audio = document.getElementById('audio'); btn.addEventListener('click',function(){ btn.style.display = 'none'; audio.play(); onloadAudio(); }) 在onLoadAudio()函数里面，我们先获取canvas元素，设置它占满整个页面，再创建canvas的对象。 var canvas = document.getElementById('canvas'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; var ctx = canvas.getContext('2d'); 创建 *AudioContext *对象，用来控制它所包含的节点的创建，以及音频处理、解码操作的执行。 var audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 通过 createAnalyser() 方法创建 *AnalyserNode *用来获取音频时间和频率数据，实现音频数据可视化。 var analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; fftSize 在 MDN 里面介绍是快速傅里叶变换的一个参数，取值必须是从32到32768范围内的2的非零幂，默认值为2048，在这里我们取512。另外，fftSize 的值决定了 frequencyData 的长度。 将音频节点关联到 AudioContext上，作为整个音频分析的输入。 我们采用MediaElementAudioSourceNode 将&lt;audio&gt;节点作为输入源，并将音频关联到分析器，再将分析器关联到输出设备。 var source = audioCtx.createMediaElementSource(audio); source.connect(analyser); analyser.connect(audioCtx.destination); 接下来获取频率数组。 var bufferLength = analyser.frequencyBinCount; var dataArray = new Uint8Array(bufferLength); frequencyBinCount()的值是 fftSize 取值的一半，所以这里的 Uint8Array() 数组的长度就是256。 然后设置音柱的宽度，而高度只定义变量而不赋值，留在后面通过dataArray[]数组动态设置 var barWidth = WIDTH / bufferLength*1.5; var barHeight; 绘制音柱定义一个 renderFrame() 函数用于绘制音柱，并且每次绘制之前都先将整个画布清除，然后更新频率数组。 ctx.clearRect(0,0,WIDTH,HEIGHT); analyser.getByteFrequencyData(dataArray);通过for循环里面设置每一个矩形的高度，再根据高度设置一个背景色，然后绘制矩形，并填充背景颜色。然后通过递归的方式调用函数。 barHeight = dataArray[i]; var r = barHeight + 25 * (i / bufferLength); var g = 250 * (i / bufferLength); var b = 50; ctx.fillStyle = \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; ctx.fillRect(x,HEIGHT-barHeight,barWidth,barHeight); x += barWidth+2; 最后，运行代码，体验属于你的可视化音乐吧。 小结本文简单介绍了 canvas 的使用和如何通过 Web Audio 的相关 API 获取音频的频率数据。 然而 canvas 和 Web Audio的用处远远不止于此，读者还可以发挥想象力和创造力，开发出更多有意思的项目。 附上项目源码：https://github.com/anpeier/lesson_shuidi/tree/master/html5/visualize document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"前端","slug":"前端","permalink":"http://anpeier.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://anpeier.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://anpeier.github.io/categories/%E5%89%8D%E7%AB%AF/"}]}]}